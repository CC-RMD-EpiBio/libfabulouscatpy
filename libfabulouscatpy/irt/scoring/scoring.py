from abc import ABC, abstractmethod
from collections import defaultdict

import numpy as np

from libfabulouscatpy.irt.prediction.irt import IRTModel


def return_zero():
    return 0.
def return_one():
    return 1.

def sample_from_cdf(x, cdf, shape=1):
    """
    Samples from a probability distribution defined by points and CDF values.

    Args:
        x: A 1D array of x-values (points). Must be monotonically increasing.
        cdf: A 1D array of CDF values corresponding to x. Must be monotonically 
             increasing, start at 0, and end at 1.
        shape: The shape of the output array (number of replications). Can be an int or a tuple.

    Returns:
        A NumPy array of samples from the distribution with the given shape.
        Returns None if input is invalid.
    """

    if not (np.all(np.diff(x) >= 0) and 
            np.all(np.diff(cdf) >= 0) and
            np.isclose(cdf[0], 0) and 
            np.isclose(cdf[-1], 1)):
        print("Error: Invalid input. 'x' and 'cdf' must be monotonically increasing.\
               'cdf' must start at 0 and end at 1.")
        return None
     # Generate uniform random numbers with the specified shape
    u = np.random.rand(*np.atleast_1d(shape)) # use * to unpack shape if it is a tuple

    # Vectorized searchsorted for efficiency
    indices = np.searchsorted(cdf, u)

    # Handle edge cases using vectorized operations
    indices = np.clip(indices, 1, len(x)-1) #clip indices to prevent index errors

    x_lower = x[indices - 1]
    x_upper = x[indices]
    cdf_lower = cdf[indices - 1]
    cdf_upper = cdf[indices]

    sampled_x = x_lower + (x_upper - x_lower) * (u - cdf_lower) / (cdf_upper - cdf_lower)

    return sampled_x
class ScoreBase(object):
    """
    Accepts the raw materials of a score and provides methods for transforming
    them into t-scores anf normalized scores. When making concrete classes,
    alter the contents fo the alpha and beta float lists as needed to generate
    correct normalized scores.
    """

    def __init__(
        self, scale, description, score, error, offset_factor=0., scaling_factor=1.
    ):
        """
        Parameters: alpha: array of floats
                            Parameter needed for normalized score.
                    beta: array of floats
                            Parameter needed for normalized score.
        """

        self.offset_factor = offset_factor
        self.scaling_factor = scaling_factor
        self.scale = scale
        self.description = description
        self.score = score
        self.error = error

    # Through defining the following rich comparison methods we induce an order
    # upon the set of objects spanned by instances of CatScore. For any two
    # instances csa_1 and csa_2, we can thus make sense of binary operations
    # such as csa_1 < csa_2, csa_1 == csa_2, etc.
    def __lt__(self, other=None):
        """
        Parameters: other: instance of CatScore()
                        Used to compare various objects
                        generated by CatScore().
        Returns:    w:  bool
                    True if less than, False otherwise.
        """

        if other is None:
            return False

        lt_0 = self.scale < other.scale
        lt_1 = (self.scale == other.scale) and (self.score < other.score)

        return lt_0 or lt_1

    def __le__(self, other=None):
        """
        Parameters: other: instance of CatScore()
                        Used to compare various objects
                        generated by CatScore().
        Returns:    w:  bool
                    True if less than or equal, False otherwise.
        """

        return self.__lt__(other) or self.__eq__(other)

    def __eq__(self, other=None):
        """
        Parameters: other: instance of CatScore()
                        Used to compare various objects
                        generated by CatScore().
        Returns:    w:  bool
                    True if equal, False otherwise.
        """

        if other is None:
            return False

        return (self.scale == other.scale) and (self.score == other.score)

    def __ne__(self, other=None):
        """
        Parameters: other: instance of CatScore()
                        Used to compare various objects
                        generated by CatScore().
        Returns:    w:  bool
                    True if not equal, False otherwise.
        """

        return not self.__eq__(other)

    def __gt__(self, other):
        """
        Parameters: other: instance of CatScore()
                        Used to compare various objects
                        generated by CatScore().
        Returns:    w:  bool
                    True if greater than, False otherwise.
        """

        if other is None:
            return True

        gt_0 = self.scale > other.scale
        gt_1 = (self.scale == other.scale) and (self.score > other.score)

        return gt_0 or gt_1

    def __ge__(self, other=None):
        """
        Parameters: other: instance of CatScore()
                        Used to compare various objects
                        generated by CatScore().
        Returns:    w:  bool
                    True if greater than or equal, False otherwise.
        """

        return self.__gt__(other) or self.__eq__(other)

    def t_score(self):
        """
        Returns:    w: float
                        The t-score corresponding to self.score.
        """

        return self.score * 10.0 + 50.0

    def t_score_se(self):
        """
        Returns:    w: float
                        The standard error associated to the t-score.
        """

        return self.precision * 10.0

    def norm_score(self):
        """
        Returns:    w: float
                        The normalized transform of self.score.
        """

        if self.beta[0] <= 0:
            return 50.0

        score = (self.score - self.alpha[self.scale]) / self.beta[self.scale]
        return score * 10.0 + 50.0

    def norm_score_se(self):
        """
        Returns:    w: float
                        The standard error for the normalized score.
        """

        if self.beta[0] <= 0:
            return 0.0

        return 10.0 * self.error / self.beta[self.scale]


class ScoringBase(ABC):

    def __init__(
        self,
        model: IRTModel | None = None,
        offset_factor: dict[str: float] | None = None,
        scaling_factor: dict[str:float] | None = None,
    ) -> None:
        self.model = model
        self.cs = ScoreBase

        if offset_factor is None:
            offset_factor = defaultdict(return_zero)
        if scaling_factor is None:
            scaling_factor = defaultdict(return_one)
        self.offset_factor = offset_factor
        self.scaling_factor = scaling_factor
        self.scored_responses = {}
        self.n_scored = defaultdict(int)

        
    @classmethod
    @abstractmethod
    def score_responses(
        self, responses: dict, scales: list[str] | None = None, **kwargs
    ) -> dict[str:ScoreBase]:
        """
        Parameters: responses: dict of responses.
        Returns:    dict(scale: w): scale: instance of CatScoreBase
        """
        return {}
